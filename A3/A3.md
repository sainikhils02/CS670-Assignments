
# Assignment 3
## CS670: Cryptographic Techniques for Privacy Preservation

### Updating Item Profiles
When a user issues a query, the item profiles are updated according to:

$$v_{j}\leftarrow v_{j}+u_{i}(1-\langle u_{i},v_{j}\rangle)$$

where $u_{i}$ is the user's profile and $v_{j}$ is the profile of the item that was queried.

1

---

**CS670**
**Assignment 3 and 4**
**06/10/2025**

### Challenge
Updating item profiles securely is non-trivial because:

* The servers, who hold secret shares of the item profiles, do not know which item j should be updated.
* The user, on the other hand, knows which item was queried, but does not know the update value $M=u_{i}(1-\langle u_{i},v_{j}\rangle)$, since it depends on $v_{j}$, which is shared between the servers.

### Ideal (Infeasible) Approach
If the user somehow knew M, they could directly perform a private update using a Distributed Point Function (DPF):

$$(k_{0},k_{1})\leftarrow Gen(j,M).$$

Each server $P_{b}$ $(b\in\{0,1\})$ could then locally update its share of the item profiles as:

$$V_{b}\leftarrow V_{b}+EvalFull(k_{b}),$$

which adds M to the $j^{th}$ position of the shared item profile vector without revealing j. However, since the user does not know M, this approach is not feasible.

### Actual Protocol
To overcome this, we proceed as follows.

**Step 1: User-side DPF generation.** The user generates a DPF that points to the desired index $i^{*}$ but carries a zero value:

$$(k_{0},k_{1})\leftarrow Gen(i^{*},1).$$

Let each key have the structure

$$k_{b}=(s_{b},cw_{0},...,cw_{h} \text{ FCW}),$$

where $FCW_{b}$ denotes the final correction word.

The user sends:

$k_{0}^{\prime}=(s_{0},cw_{0},...,cw_{h},FCW_{0})$ to $P_{0}$
$k_{1}^{\prime}=(s_{1},cw_{0},...,cw_{h},FCW_{1})$ to $P_{1}$,

such that

$$FCW_{0}+FCW_{1}=FCW.$$

Page 2 of 4

---

**CS670**
**Assignment 3 and 4**
**06/10/2025**

**Step 2: Server-side computation of the update value.** Each server locally computes its share of the update term:

$$M=u_{i}(1-\langle u_{i},v_{j}\rangle).$$

Denote these shares as $M_{0}$ and $M_{1}$ such that:

$$M=M_{0}+M_{1}.$$

**Step 3: Adjusting the DPF final correction word.** Each server modifies the final correction word of its DPF key so that the combined DPF now encodes M (instead of 0) at index i*.

Each server sends the masked difference:

$P_{0}:M_{0}-FCW_{0}-1$
$P_{1}:M_{1}-FCW_{1}$.

After exchanging these values, both servers compute:

$FCW_{m}=(M_{0}-FCW_{0})+(M_{1}-FCW_{1}-1)$ .

The updated DPF keys are thus:

$$k_{b}=(s_{b},cw_{0},...,cw_{h},FCW_{m}).$$

**Step 4: Applying the update.** Each server evaluates its DPF key and adds the result to its share of the item profiles:

$$V_{b}\leftarrow V_{b}+EvalFull(k_{b}).$$

This procedure correctly and privately applies the update M to the item profile $v_{j}$, without revealing the target index j or the update value M to either server or the user.

### Conversion from XOR to Additive Shares.
1.  Note that the output of EvalFull will be in the form of XOR shares, whereas the item profiles are stored as additive shares. To make the update compatible, we must convert the XOR shares into additive shares.
2.  This can be done by having one of the parties multiply its vector by -1. However, the challenge lies in determining which party should perform this negation. If the wrong party multiplies by -1, the result will have a sign error.
3.  For the purposes of this assignment, you may assume an insecure method for determining which party negates its vector. Implementing the conversion securely will earn you bonus points.

### Grading
* Correctness and Security: 80%
* Code clarity and documentation: 20%

Page 3 of 4

---